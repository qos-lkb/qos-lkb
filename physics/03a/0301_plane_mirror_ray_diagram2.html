<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¹³é¢é¡åå°„ - å…‰ç·šåœ–æ¨¡æ“¬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            overflow: hidden; /* Prevent scrolling when dragging on touch devices */
            touch-action: none;
        }

        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }

        /* Custom hatch pattern for the back of the mirror */
        .mirror-back {
            background-image: repeating-linear-gradient(
                -45deg,
                transparent,
                transparent 5px,
                #9CA3AF 5px,
                #9CA3AF 6px
            );
        }
    </style>
</head>
<body class="bg-gray-100 h-screen w-screen flex flex-col select-none">

    <!-- Header / Controls -->
    <div class="absolute top-4 left-4 z-10 bg-white/90 backdrop-blur-sm p-4 rounded-xl shadow-lg border border-gray-200 max-w-sm">
        <h1 class="text-xl font-bold text-gray-800 mb-2">å¹³é¢é¡åå°„ (Reflection by Plane Mirror)</h1>
        <div class="text-sm text-gray-600 space-y-1">
            <p>ğŸ”´ <span class="font-bold">ç‰©é«” (Object)</span>: æ‹–æ›³ä»¥æ”¹è®Šä½ç½®</p>
            <p class="text-gray-500 text-xs mt-2">* ç•™æ„ u (ç‰©è·) å’Œ v (åƒè·) çš„é—œä¿‚</p>
        </div>
        <!-- é ‚éƒ¨æ•¸å€¼é¡¯ç¤ºå¯ä¿ç•™ä¹Ÿå¯ç§»é™¤ï¼Œé€™è£¡ä¿ç•™ä½œç‚ºè¼”åŠ© -->
        <div class="mt-3 flex items-center space-x-4 text-sm font-mono bg-gray-50 p-2 rounded">
            <div class="text-red-600">u = <span id="dist-u">0</span> cm</div>
            <div class="text-gray-400">|</div>
            <div class="text-indigo-600">v = <span id="dist-v">0</span> cm</div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div class="relative w-full h-full cursor-crosshair" id="canvas-container">
        <canvas id="simulationCanvas" class="block w-full h-full"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const uLabel = document.getElementById('dist-u');
        const vLabel = document.getElementById('dist-v');

        // State
        let width, height, mirrorX;
        let scale = 1; // Pixels per logical unit
        const gridSpacing = 40; // Pixels
        const cmRatio = 40; // 40px = 1 unit (cm)
        
        // Positions (Initialize in resize)
        let objectPos = { x: 0, y: 0 };
        
        // Interaction State
        let isDraggingObject = false;
        const hitRadius = 30; // Easy to touch on iPad

        function init() {
            window.addEventListener('resize', resize);
            
            // Mouse Events
            canvas.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('mouseup', handleEnd);

            // Touch Events (Passive false for preventing scroll)
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            window.addEventListener('touchmove', handleMove, { passive: false });
            window.addEventListener('touchend', handleEnd);

            resize();
            loop();
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            
            mirrorX = width / 2;

            // Initial positions if not set or out of bounds
            // Reset to 5cm in front of mirror (5 * cmRatio), vertically centered
            if (objectPos.x === 0 || objectPos.x > mirrorX) {
                objectPos = { x: mirrorX - (5 * cmRatio), y: height / 2 };
            }

            draw();
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(e) {
            e.preventDefault(); // Prevent scrolling on iPad
            const pos = getPos(e);
            const distObj = Math.hypot(pos.x - objectPos.x, pos.y - objectPos.y);

            if (distObj < hitRadius) {
                isDraggingObject = true;
                container.classList.add('cursor-grabbing');
            }
        }

        function handleMove(e) {
            if (!isDraggingObject) return;
            e.preventDefault();
            
            const pos = getPos(e);

            // Clamp positions to stay in front of mirror (Left side) + padding
            const maxX = mirrorX - 10;
            const minX = 10;
            const minY = 10;
            const maxY = height - 10;

            const clampedX = Math.max(minX, Math.min(pos.x, maxX));
            const clampedY = Math.max(minY, Math.min(pos.y, maxY));

            objectPos = { x: clampedX, y: clampedY };
        }

        function handleEnd() {
            isDraggingObject = false;
            container.classList.remove('cursor-grabbing');
        }

        function drawGrid() {
            ctx.strokeStyle = '#e5e7eb'; // Light gray like graph paper
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = mirrorX; x < width; x += gridSpacing) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
            }
            for (let x = mirrorX; x > 0; x -= gridSpacing) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
            }

            // Horizontal lines
            const centerY = height / 2;
            for (let y = centerY; y < height; y += gridSpacing) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            }
            for (let y = centerY; y > 0; y -= gridSpacing) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            }
        }

        function drawMirror() {
            // Mirror Line
            ctx.beginPath();
            ctx.moveTo(mirrorX, 0);
            ctx.lineTo(mirrorX, height);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Hatches (Back of mirror - Right side)
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 2;
            for (let y = 0; y < height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(mirrorX, y);
                ctx.lineTo(mirrorX + 15, y + 15);
                ctx.stroke();
            }

            // Labels
            ctx.fillStyle = '#374151';
            ctx.font = '14px "Noto Sans TC"';
            ctx.fillText('Front (é¡å‰)', mirrorX - 80, 30);
            ctx.fillText('Back (é¡å¾Œ)', mirrorX + 15, 30);
        }

        function drawArrow(fromX, fromY, toX, toY, color) {
            const headlen = 10; // length of head in pixels
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            // Midpoint for the arrow
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;

            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headlen * Math.cos(angle - Math.PI / 6), midY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - headlen * Math.cos(angle + Math.PI / 6), midY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawRay(start, end, type) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            
            if (type === 'virtual') {
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#9CA3AF'; // Gray dashed
            } else if (type === 'incident') {
                ctx.setLineDash([]);
                ctx.strokeStyle = '#DC2626'; // Red
            } else if (type === 'reflected') {
                ctx.setLineDash([]);
                ctx.strokeStyle = '#DC2626'; // Red
            }
            
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]); // Reset

            // Draw arrow in middle if solid
            if (type === 'incident' || type === 'reflected') {
                drawArrow(start.x, start.y, end.x, end.y, '#DC2626');
            }
        }

        function drawDimensionLine(x1, x2, y, label, color) {
            const tickSize = 5;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // Main line
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x2, y);
            ctx.stroke();

            // Ticks at ends
            ctx.beginPath();
            ctx.moveTo(x1, y - tickSize);
            ctx.lineTo(x1, y + tickSize);
            ctx.moveTo(x2, y - tickSize);
            ctx.lineTo(x2, y + tickSize);
            ctx.stroke();

            // Arrowheads (optional, but good for dimension)
            // Left arrow
            ctx.beginPath();
            ctx.moveTo(x1, y);
            ctx.lineTo(x1 + 5, y - 3);
            ctx.lineTo(x1 + 5, y + 3);
            ctx.fill();
             // Right arrow
            ctx.beginPath();
            ctx.moveTo(x2, y);
            ctx.lineTo(x2 - 5, y - 3);
            ctx.lineTo(x2 - 5, y + 3);
            ctx.fill();

            // Text Label
            ctx.font = 'bold 14px "Noto Sans TC"';
            ctx.textAlign = 'center';
            // Determine if label fits or needs offset
            const midX = (x1 + x2) / 2;
            // Draw background for text to read easier over grid
            const textWidth = ctx.measureText(label).width;
            ctx.fillStyle = 'rgba(243, 244, 246, 0.8)'; // light gray bg
            ctx.fillRect(midX - textWidth/2 - 4, y - 10, textWidth + 8, 20);
            
            ctx.fillStyle = color;
            ctx.fillText(label, midX, y + 5);
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            drawGrid();
            drawMirror();

            // 1. Calculate Image Position
            // The image is equidistant from the mirror on the opposite side.
            const objectDistance = mirrorX - objectPos.x;
            const imagePos = {
                x: mirrorX + objectDistance,
                y: objectPos.y
            };

            // Values for display
            const uVal = (objectDistance / cmRatio).toFixed(1);
            const vVal = ((imagePos.x - mirrorX) / cmRatio).toFixed(1);

            // Update UI Labels
            uLabel.innerText = uVal;
            vLabel.innerText = vVal;

            // 2. Define Ray Targets (Hit points on mirror)
            // Updated: Rays target the center of the mirror regardless of object position
            // ä¸‰æ¢å…¥å°„ç·šå°„å‘é¡é¢ä¸­å¤®çš„ä½ç½®
            const mirrorCenterY = height / 2;
            const hitYs = [mirrorCenterY - 60, mirrorCenterY, mirrorCenterY + 60]; 
            
            hitYs.forEach(y => {
                const hitPoint = { x: mirrorX, y: y };

                // A. Incident Ray (Object -> Mirror) / å…¥å°„ç·šï¼šå¾ç‰©é«”åˆ°é¡å­
                drawRay(objectPos, hitPoint, 'incident');

                // B. Virtual Ray (Image -> Mirror) - Dashed extension / è™›ç·šï¼šå¾å½±åƒåˆ°é¡å­
                drawRay(imagePos, hitPoint, 'virtual');

                // C. Reflected Ray (Mirror -> Outwards) / åå°„ç·šï¼šå¾é¡å­åå°„å›å·¦å´
                // The reflected ray appears to come FROM the Image, passing through the HitPoint
                // But it travels to the LEFT (Real world side).
                // åå°„ç·šçœ‹ä¼¼ä¾†è‡ªå½±åƒï¼Œç©¿éå…¥å°„é»ï¼Œå°„å‘çœŸå¯¦ä¸–ç•Œï¼ˆå·¦å´ï¼‰
                
                const dx = hitPoint.x - imagePos.x; // Negative value (mirror is left of image)
                const dy = hitPoint.y - imagePos.y;
                
                if (dx !== 0) {
                    const slope = dy / dx;
                    // We want to draw the ray extending to the Left edge of screen (x = 0)
                    // Line eq: y - y1 = m(x - x1)
                    // Calculate y at x = 0
                    const endX = 0; 
                    const endY = hitPoint.y + slope * (endX - hitPoint.x);
                    
                    drawRay(hitPoint, {x: endX, y: endY}, 'reflected');
                }
            });

            // 3. Draw Axis Line (Object to Image)
            ctx.beginPath();
            ctx.moveTo(objectPos.x, objectPos.y);
            ctx.lineTo(imagePos.x, objectPos.y); // Horizontal axis
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Right angle symbol
            const size = 10;
            ctx.beginPath();
            ctx.moveTo(mirrorX - size, objectPos.y);
            ctx.lineTo(mirrorX - size, objectPos.y - size);
            ctx.lineTo(mirrorX, objectPos.y - size);
            ctx.strokeStyle = '#000';
            ctx.stroke();

            // 4. Draw Image (Virtual)
            ctx.beginPath();
            ctx.arc(imagePos.x, imagePos.y, 8, 0, Math.PI * 2);
            ctx.strokeStyle = '#4B5563'; 
            ctx.setLineDash([2, 2]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
            
            ctx.fillStyle = '#4B5563';
            ctx.textAlign = 'left';
            ctx.font = 'italic 14px "Noto Sans TC"';
            ctx.fillText('Image', imagePos.x + 15, imagePos.y - 15);
            ctx.font = 'bold 14px "Noto Sans TC"';
            ctx.fillText('I', imagePos.x - 4, imagePos.y + 4);

            // 5. Draw Object (Real)
            ctx.beginPath();
            ctx.arc(objectPos.x, objectPos.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#DC2626'; 
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#DC2626';
            ctx.textAlign = 'right';
            ctx.font = 'bold 14px "Noto Sans TC"';
            ctx.fillText('Object', objectPos.x - 15, objectPos.y - 15);
            ctx.fillText('O', objectPos.x - 3, objectPos.y + 4);

            // 6. Draw Dimension Lines (u and v)
            // Position them slightly below the lowest ray or fixed below object
            const dimY = objectPos.y + 100; // Shift down to avoid clutter
            
            // Draw u
            drawDimensionLine(objectPos.x, mirrorX, dimY, `u = ${uVal} cm`, '#DC2626');
            
            // Draw v
            drawDimensionLine(mirrorX, imagePos.x, dimY, `v = ${vVal} cm`, '#4F46E5'); // Indigo color for image
        }

        function loop() {
            draw();
            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>
</html>